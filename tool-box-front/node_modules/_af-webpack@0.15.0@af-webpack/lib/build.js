"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = build;

var _stringify = _interopRequireDefault(require("@babel/runtime/core-js/json/stringify"));

var _webpack = _interopRequireDefault(require("webpack"));

var _chalk = _interopRequireDefault(require("chalk"));

var _rimraf = require("rimraf");

var _assert = _interopRequireDefault(require("assert"));

var _isPlainObject = _interopRequireDefault(require("is-plain-object"));

var _formatWebpackMessages = _interopRequireDefault(require("react-dev-utils/formatWebpackMessages"));

var _printBuildError = _interopRequireDefault(require("react-dev-utils/printBuildError"));

var _FileSizeReporter = require("react-dev-utils/FileSizeReporter");

var _applyWebpackConfig = require("./applyWebpackConfig");

var debug = require('debug')('af-webpack:build');

if (!process.env.NO_COMPRESS) {
  process.env.NODE_ENV = 'production';
} // These sizes are pretty large. We'll warn for bundles exceeding them.


var WARN_AFTER_BUNDLE_GZIP_SIZE = 512 * 1024;
var WARN_AFTER_CHUNK_GZIP_SIZE = 1024 * 1024;

function buildWebpack() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var webpackConfig = opts.webpackConfig,
      watch = opts.watch,
      success = opts.success;
  debug("webpack config: ".concat((0, _stringify.default)(webpackConfig)));
  debug("Clean output path ".concat(webpackConfig.output.path.replace("".concat(process.cwd(), "/"), '')));
  (0, _rimraf.sync)(webpackConfig.output.path);

  function successHandler(_ref) {
    var stats = _ref.stats,
        warnings = _ref.warnings;

    if (warnings.length) {
      console.log(_chalk.default.yellow('Compiled with warnings.\n'));
      console.log(warnings.join('\n\n'));
    } else {
      console.log(_chalk.default.green('Compiled successfully.\n'));
    }

    console.log('File sizes after gzip:\n');
    (0, _FileSizeReporter.printFileSizesAfterBuild)(stats, {
      root: webpackConfig.output.path,
      sizes: {}
    }, webpackConfig.output.path, WARN_AFTER_BUNDLE_GZIP_SIZE, WARN_AFTER_CHUNK_GZIP_SIZE);
    console.log();

    if (success) {
      success({
        stats: stats,
        warnings: warnings
      });
    }
  }

  function errorHandler(err) {
    console.log(_chalk.default.red('Failed to compile.\n'));
    (0, _printBuildError.default)(err);
    debug(err);
    if (!watch) process.exit(1);
  }

  function doneHandler(err, stats) {
    debug('build done');

    if (err) {
      return errorHandler(err);
    }

    var messages = (0, _formatWebpackMessages.default)(stats.toJson({}, true));

    if (messages.errors.length) {
      if (messages.errors.length > 1) {
        messages.errors.length = 1;
      }

      return errorHandler(new Error(messages.errors.join('\n\n')));
    }

    return successHandler({
      stats: stats,
      warnings: messages.warnings
    });
  }

  var compiler = (0, _webpack.default)(webpackConfig);

  if (watch) {
    compiler.watch(200, doneHandler);
  } else {
    compiler.run(doneHandler);
  }
}

function build() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var webpackConfig = opts.webpackConfig;
  (0, _assert.default)(webpackConfig, 'webpackConfig should be supplied.');
  (0, _assert.default)((0, _isPlainObject.default)(webpackConfig), 'webpackConfig should be plain object.'); // 存在 webpack.config.js 时提醒用户

  (0, _applyWebpackConfig.warnIfExists)();
  buildWebpack(opts);
}